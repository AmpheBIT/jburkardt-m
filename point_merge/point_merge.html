<html>

  <head>
    <title>
      POINT_MERGE - Count or Index Unique or Tolerably Unique Points
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      POINT_MERGE <br> Count or Index Unique or Tolerably Unique Points
    </h1>

    <hr>

    <p>
      <b>POINT_MERGE</b>
      is a MATLAB library which
      deals with the problem of counting or indexing the unique or
      "tolerably unique" points in a collection of N points in 
      M dimensional space.
    </p>

    <p>
      This problem is distinct from, though similar to, problems such
      as finding the nearest neighbor, or counting all the points that
      lie within a given distance of each point, or finding the optimal
      assignment of N points into K clusters (the K-Means problem).
    </p>

    <p>
      The "tolerably unique" problem is the "Starbucks problem", that is,
      the task of choosing a list of Starbucks cafes to shut down, so that
      there is no Starbucks cafe across the street from another one.
      The Starbucks cafes that remain open are "tolerably unique", that
      is, there is now no other open cafe within the given tolerance.
    </p>

    <p>
      Given sets of data with some points very close to each other,
      there are a number of ways of resolving the data.  Here, a simpleminded
      approach is taken, in which we start with one tolerably unique point,
      and consider the remaining points one at a time, accepting the next
      point as long as it is not closer than the tolerance to some already 
      accepted point.  
    </p>

    <p>
      This is a simpler approach than trying to maximize the number of points
      you can have in the set, while satisfying the tolerance, or of trying
      to replace two nearby points by their average, for instance.
    </p>

    <p>
      For the unique case, in 1D, a simple and efficient procedure sorts
      the data, and then compares consecutive entries.
      For the unique case in multiple dimensions, the sorting procedure
      can still be used.
    </p>

    <p>
      For the "tolerably unique" case in 1D, the same sorting procedure
      can be used, but in multiple dimensions, the usual kinds of lexicographic
      sorting will interleave near and far points in a way that is
      hard to deal with.
    </p>

    <p>
      A reliable method for the tolerably unique case in multiple dimensions
      is simply to compute the distance between every pair of points.
      However, this is an O(N^2) computation, and becomes terribly unsuitable
      when the number of points considered is in the tens of thousands or more.
    </p>

    <p>
      The "radial" approach, implemented in <b>POINT_RADIAL_TOL_UNIQUE_COUNT</b>,
      picks a random base point Z, computes the radial distance R(I) of each point
      P(I) to Z, and then sorts the data by R.  It then counts tolerably unique
      items by inspecting the R array in order.  Two points are possible 
      neighbors only if they lie within a TOL interval in R.  Assuming the
      points are in general position, the number of points that need to be
      compared will be small enough that this algorithm is essentially O(N)
      rather than O(N^2).
    </p>

    <p>
      In MATLAB, the <b>unique</b> command can select the unique points;
      there is also a user-written function called <b>consolidator</b>
      that can merge points with a tolerance.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files described and made available on this web page 
      are distributed under
      <a href = "../../txt/gnu_lgpl.txt">the GNU LGPL license.</a>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>POINT_MERGE</b> is available in
      <a href = "../../c_src/point_merge/point_merge.html">a C version</a> and
      <a href = "../../cpp_src/point_merge/point_merge.html">a C++ version</a> and
      <a href = "../../f77_src/point_merge/point_merge.html">a FORTRAN77 version</a> and
      <a href = "../../f_src/point_merge/point_merge.html">a FORTRAN90 version</a> and
      <a href = "../../m_src/point_merge/point_merge.html">a MATLAB version</a>.
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../../cpp_src/ann/ann.html">
      ANN</a>, 
      a C++ library which
      computes Approximate Nearest Neighbors, 
      by David Mount, Sunil Arya;
    </p>

    <p>
      <a href = "../../cpp_src/ann_test/ann_test.html">
      ANN_TEST</a>, 
      a C++ program which 
      uses ann to approximate the nearest
      neighbors of a set of points stored in a file;
    </p>

    <p>
      <a href = "../../datasets/cities/cities.html">
      CITIES</a>,
      a dataset directory which
      contains sets of information about cities and the distances between them; 
    </p>

    <p>
      <a href = "../../m_src/cities/cities.html">
      CITIES</a>,
      a MATLAB library which
      handles various problems associated with a set of "cities" on a map.
    </p>

    <p>
      <a href = "../../m_src/kmeans/kmeans.html">
      KMEANS</a>, 
      a MATLAB library which
      contains several different algorithms for the K-Means problem.
    </p>

    <p>
      <a href = "../../f_src/spaeth/spaeth.html">
      SPAETH</a>, 
      a FORTRAN90 library which 
      can cluster data according to various principles.
    </p>

    <p>
      <a href = "../../f_src/spaeth2/spaeth2.html">
      SPAETH2</a>, 
      a FORTRAN90 library which   
      can cluster data according to various principles.
    </p>

    <p>
      <a href = "../../m_src/table_merge/table_merge.html">
      TABLE_MERGE</a>, 
      a MATLAB program which
      reads a file of N points in M dimensions, removes duplicates or points 
      that are closer than some tolerance, and writes the reduced set of points
      to a file.
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "i4_uniform.m">i4_uniform.m</a>, 
          returns a pseudorandom I4 in a given range;
        </li>
        <li>
          <a href = "i4vec_print.m">i4_print.m</a>, 
          prints an I4VEC;
        </li>
        <li>
          <a href = "point_radial_tol_unique_count.m">point_radial_tol_unique_count.m</a>, 
          counts tolerably unique points.
        </li>
        <li>
          <a href = "point_radial_tol_unique_index.m">point_radial_tol_unique_index.m</a>, 
          indexes tolerably unique points.
        </li>
        <li>
          <a href = "point_radial_unique_count.m">point_radial_unique_count.m</a>, 
          counts unique points.
        </li>
        <li>
          <a href = "point_tol_unique_count.m">point_tol_unique_count.m</a>, 
          counts tolerably unique points.
        </li>
        <li>
          <a href = "point_tol_unique_index.m">point_tol_unique_index.m</a>, 
          indexes tolerably unique points.
        </li>
        <li>
          <a href = "point_unique_count.m">point_unique_count.m</a>, 
          counts unique points.
        </li>
        <li>
          <a href = "point_unique_index.m">point_unique_index.m</a>, 
          indexes unique points.
        </li>
        <li>
          <a href = "r8col_duplicates.m">
          r8col_duplicates.m</a>, 
          generates an R8COL with some duplicate columns;
        </li>
        <li>
          <a href = "r8col_sort_heap_index_a.m">r8col_sort_heap_index_a.m</a>, 
          computes an index vector to ascending sort an R8COL;
        </li>
        <li>
          <a href = "r8mat_transpose_print.m">r8mat_transpose_print.m</a>, 
          prints the transpose of an R8MAT;
        </li>
        <li>
          <a href = "r8mat_transpose_print_some.m">
          r8mat_transpose_print_some.m</a>, 
          prints some of the transpose of an R8MAT;
        </li>
        <li>
          <a href = "r8mat_uniform_01.m">r8mat_uniform_01.m</a>, 
          returns a unit pseudorandom R8MAT;
        </li>
        <li>
          <a href = "r8vec_compare.m">r8vec_compare.m</a>, 
          compares the order of two R8VEC's;
        </li>
        <li>
          <a href = "r8vec_print.m">r8vec_print.m</a>, 
          prints an R8VEC;
        </li>
        <li>
          <a href = "r8vec_sort_heap_index_a.m">r8vec_sort_heap_index_a.m</a>, 
          computes an index vector to ascending sort an R8VEC;
        </li>
        <li>
          <a href = "r8vec_uniform_01.m">r8vec_uniform_01.m</a>, 
          returns a unit pseudorandom R8VEC.
        </li>
        <li>
          <a href = "timestamp.m">timestamp.m</a>, 
          prints the current YMDHMS date as a timestamp;
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "point_merge_test.m">point_merge_test.m</a>,
          calls all the tests.
        </li>
        <li>
          <a href = "point_merge_test01.m">point_merge_test01.m</a>,
          tests uniqueness counting with no tolerance. 
        </li>
        <li>
          <a href = "point_merge_test02.m">point_merge_test02.m</a>,
          tests uniqueness counting with a tolerance. 
        </li>
        <li>
          <a href = "point_merge_test03.m">point_merge_test03.m</a>,
          compares timings for two uniqueness counters.
        </li>
        <li>
          <a href = "point_merge_test04.m">point_merge_test04.m</a>,
          tests uniqueness indexing with a tolerance.
        </li>
        <li>
          <a href = "point_merge_test05.m">point_merge_test05.m</a>,
          times uniqueness indexing with a tolerance.
        </li>
        <li>
          <a href = "point_merge_test_output.txt">point_merge_test_output.txt</a>,
          the output file.
        </li>
      </ul>
    </p>

    <p>
      You can go up one level to <a href = "../m_src.html">
      the MATLAB source codes</a>.
    </p>

    <hr>

    <i>
      Last revised on 23 July 2010.
    </i>

    <!-- John Burkardt -->

  </body>

  <!-- Initial HTML skeleton created by HTMLINDEX. -->

</html>
